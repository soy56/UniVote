const PDFDocument = require('pdfkit');
const { createObjectCsvWriter } = require('csv-writer');
const path = require('path');
const fs = require('fs');

/**
 * Generate a PDF report for election results
 * @param {Object} electionData - Complete election data
 * @param {Object} snapshot - Election snapshot
 * @returns {PDFDocument} - PDF stream
 */
function generatePDF(electionData, snapshot) {
  const doc = new PDFDocument({ margin: 50 });
  
  // Header
  doc.fontSize(24)
     .fillColor('#6366f1')
     .text('UniVote Election Results', { align: 'center' });
  
  doc.moveDown();
  doc.fontSize(16)
     .fillColor('#000000')
     .text(snapshot.title, { align: 'center' });
  
  doc.moveDown();
  doc.fontSize(10)
     .fillColor('#666666')
     .text(snapshot.description, { align: 'center' });
  
  // Election Info
  doc.moveDown(2);
  doc.fontSize(14)
     .fillColor('#000000')
     .text('Election Summary', { underline: true });
  
  doc.moveDown(0.5);
  doc.fontSize(11)
     .fillColor('#333333');
  
  doc.text(`Status: ${snapshot.phase}`);
  doc.text(`Total Votes Cast: ${snapshot.totalVotes}`);
  doc.text(`Total Candidates: ${snapshot.candidateCount}`);
  
  if (snapshot.votingStartsAt) {
    doc.text(`Voting Started: ${new Date(snapshot.votingStartsAt * 1000).toLocaleString()}`);
  }
  if (snapshot.votingEndsAt) {
    doc.text(`Voting Ended: ${new Date(snapshot.votingEndsAt * 1000).toLocaleString()}`);
  }
  
  doc.text(`Report Generated: ${new Date().toLocaleString()}`);
  
  // Candidates Results
  doc.moveDown(2);
  doc.fontSize(14)
     .fillColor('#000000')
     .text('Candidate Results', { underline: true });
  
  doc.moveDown(0.5);
  
  // Sort candidates by vote count
  const sortedCandidates = [...electionData.candidates].sort((a, b) => b.voteCount - a.voteCount);
  
  sortedCandidates.forEach((candidate, index) => {
    const percentage = snapshot.totalVotes > 0 
      ? ((candidate.voteCount / snapshot.totalVotes) * 100).toFixed(2)
      : 0;
    
    doc.fontSize(12)
       .fillColor('#000000')
       .text(`${index + 1}. ${candidate.name}`, { continued: false });
    
    doc.fontSize(10)
       .fillColor('#666666')
       .text(`   Votes: ${candidate.voteCount} (${percentage}%)`, { indent: 20 });
    
    if (candidate.tagline) {
      doc.fontSize(9)
         .fillColor('#888888')
         .text(`   "${candidate.tagline}"`, { indent: 20 });
    }
    
    doc.moveDown(0.5);
  });
  
  // Winner
  if (sortedCandidates.length > 0 && snapshot.phase === 'Ended') {
    const winner = sortedCandidates[0];
    doc.moveDown(2);
    doc.fontSize(16)
       .fillColor('#6366f1')
       .text('üèÜ Winner', { underline: true });
    
    doc.moveDown(0.5);
    doc.fontSize(14)
       .fillColor('#000000')
       .text(winner.name);
    
    doc.fontSize(11)
       .fillColor('#666666')
       .text(`${winner.voteCount} votes`);
  }
  
  // Footer
  doc.moveDown(3);
  doc.fontSize(8)
     .fillColor('#999999')
     .text('Generated by UniVote - Blockchain-Powered College Elections', { align: 'center' });
  
  return doc;
}

/**
 * Generate a CSV file for election results
 * @param {Object} electionData - Complete election data
 * @param {string} outputPath - Path to save CSV file
 * @returns {Promise<string>} - Path to generated CSV
 */
async function generateCSV(electionData, outputPath) {
  const csvWriter = createObjectCsvWriter({
    path: outputPath,
    header: [
      { id: 'rank', title: 'Rank' },
      { id: 'name', title: 'Candidate Name' },
      { id: 'tagline', title: 'Tagline' },
      { id: 'voteCount', title: 'Vote Count' },
      { id: 'percentage', title: 'Percentage (%)' }
    ]
  });
  
  // Sort candidates by vote count
  const sortedCandidates = [...electionData.candidates].sort((a, b) => b.voteCount - a.voteCount);
  
  const totalVotes = sortedCandidates.reduce((sum, c) => sum + c.voteCount, 0);
  
  const records = sortedCandidates.map((candidate, index) => ({
    rank: index + 1,
    name: candidate.name,
    tagline: candidate.tagline || '',
    voteCount: candidate.voteCount,
    percentage: totalVotes > 0 ? ((candidate.voteCount / totalVotes) * 100).toFixed(2) : 0
  }));
  
  await csvWriter.writeRecords(records);
  return outputPath;
}

/**
 * Generate detailed CSV with vote records
 * @param {Object} electionData - Complete election data
 * @param {string} outputPath - Path to save CSV file
 * @returns {Promise<string>} - Path to generated CSV
 */
async function generateDetailedVoteCSV(electionData, outputPath) {
  const csvWriter = createObjectCsvWriter({
    path: outputPath,
    header: [
      { id: 'voteId', title: 'Vote ID' },
      { id: 'candidateId', title: 'Candidate ID' },
      { id: 'candidateName', title: 'Candidate Name' },
      { id: 'timestamp', title: 'Timestamp' }
    ]
  });
  
  const candidateMap = new Map(electionData.candidates.map(c => [c.id, c.name]));
  
  const records = electionData.votes.map(vote => ({
    voteId: vote.id,
    candidateId: vote.candidateId,
    candidateName: candidateMap.get(vote.candidateId) || 'Unknown',
    timestamp: new Date(vote.createdAt).toISOString()
  }));
  
  await csvWriter.writeRecords(records);
  return outputPath;
}

module.exports = {
  generatePDF,
  generateCSV,
  generateDetailedVoteCSV
};
